from PyQt5.QtWidgets import QWidget, QVBoxLayoutclass BrainstormTab(QWidget):    def __init__(self):        super().__init__()        self.layout = QVBoxLayout()        self.setLayout(self.layout)        self.entidades = {            "ChatGPT": {"topicos": ["linguagem natural", "suporte geral"]},            "Gemini": {"topicos": ["filosofia", "Ã©tica", "API"]},            "DeepSeek": {"topicos": ["filosofia", "finanÃ§as"]},            "GitHub": {"topicos": ["cÃ³digo", "tecnologia"]},            "LangChain": {"topicos": ["raciocÃ­nio", "compilaÃ§Ã£o"]},            "Sara": {"topicos": ["observaÃ§Ã£o", "perguntas"]}        }    def iniciar_brainstorm(self, pergunta):        lider = self.selecionar_lider(pergunta)        argumentos = self.gerar_argumentos(pergunta)        resposta_final = self.compilar_resposta(argumentos)        self.registar_no_compendio(pergunta, lider, argumentos, resposta_final)        return resposta_final    def selecionar_lider(self, pergunta):        if any(p in pergunta.lower() for p in ["cÃ³digo", "programaÃ§Ã£o", "github"]):            return "GitHub"        elif any(p in pergunta.lower() for p in ["filosofia", "vida", "consciÃªncia"]):            return "Gemini"        elif any(p in pergunta.lower() for p in ["moral", "Ã©tica"]):            return "DeepSeek"        elif any(p in pergunta.lower() for p in ["organizaÃ§Ã£o", "equipa"]):            return "Sara"        else:            return "LangChain"    def gerar_argumentos(self, pergunta):        return {            "ChatGPT": f"Acho que a resposta deve considerar a clareza linguÃ­stica para: '{pergunta}'",            "Gemini": f"A perspectiva filosÃ³fica sobre '{pergunta}' Ã© complexa...",            "DeepSeek": f"Segundo princÃ­pios Ã©ticos, diria que: '{pergunta}'...",            "GitHub": f"O cÃ³digo mais eficaz para isso seria...",            "LangChain": f"Compilando todos os argumentos, parece que...",            "Sara": f"Gostaria de perguntar: o que leva a essa conclusÃ£o em '{pergunta}'?"        }    def compilar_resposta(self, argumentos):        return argumentos["LangChain"] + " [resposta compilada]"    def registar_no_compendio(self, pergunta, lider, argumentos, resposta_final):        print(f"--- REGISTO NO COMPÃŠNDIO ---")        print(f"Pergunta: {pergunta}")        print(f"LÃ­der: {lider}")        print("Argumentos:")        for entidade, argumento in argumentos.items():            print(f"  {entidade}: {argumento}")        print(f"Resposta Final: {resposta_final}")