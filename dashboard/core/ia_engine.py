import reimport fitzimport pytesseractfrom PIL import Imageimport docximport osclass IACentral:    def __init__(self):        self.ia_local = self        self.ias_externas = {            "gpt": self._fake_ia_externa,            "gemini": self._fake_ia_externa,            "deepseek": self._fake_ia_externa,            "github": self._fake_ia_externa        }    def responder(self, pergunta):        if pergunta.startswith('[BROWSER]'):            return self._processar_browser(pergunta.replace('[BROWSER]', '').strip())        if pergunta.startswith("[SCRAPING]"):            return self._processar_scraping(pergunta)        print(f"[IA Engine] Nova pergunta recebida: {pergunta}")        if self._contem_dados_sensiveis(pergunta):            return self.responder_local(pergunta)        if self._tarefa_simples(pergunta):            return self.responder_local(pergunta)        if self._tarefa_com_criterios_especificos(pergunta):            modelo = self._selecionar_ia_por_tarefa(pergunta)            return self.ias_externas[modelo](pergunta)        for nome, metodo in self.ias_externas.items():            resposta = metodo(pergunta)            if resposta and len(resposta.strip()) > 10:                return resposta        return self.responder_local(pergunta)    def _processar_scraping(self, pedido):        try:            instrucao, path = pedido.replace("[SCRAPING]", "").split("->")            instrucao = instrucao.strip()            path = path.strip()            if not os.path.exists(path):                return "âŒ O ficheiro selecionado nÃ£o existe."            texto_extraido = ""            if path.lower().endswith(".pdf"):                texto_extraido = self._extrair_pdf(path)            elif path.lower().endswith(".docx"):                texto_extraido = self._extrair_docx(path)            elif path.lower().endswith((".png", ".jpg", ".jpeg")):                texto_extraido = self._extrair_imagem(path)            elif path.lower().endswith(".txt"):                with open(path, "r", encoding="utf-8") as f:                    texto_extraido = f.read()            else:                return "âš ï¸ Formato de ficheiro nÃ£o suportado para scraping."            resumo = self._interpretar_texto(instrucao, texto_extraido)            return f"ðŸ¤– A IA analisou o ficheiro com base na tua instruÃ§Ã£o:\n\nðŸ“Œ InstruÃ§Ã£o: {instrucao}\n\nðŸ“„ ConteÃºdo relevante:\n{resumo}"        except Exception as e:            return f"âŒ Erro ao processar scraping: {str(e)}"    def _extrair_pdf(self, path):        doc = fitz.open(path)        return "\n".join([page.get_text() for page in doc])    def _extrair_docx(self, path):        doc = docx.Document(path)        return "\n".join([para.text for para in doc.paragraphs])    def _extrair_imagem(self, path):        img = Image.open(path)        return pytesseract.image_to_string(img)    def _interpretar_texto(self, instrucao, texto):        resultado = []        instrucao_lower = instrucao.lower()        if any(palavra in instrucao_lower for palavra in ["pagamento", "fatura", "valor", "preÃ§o"]):            valores = re.findall(r"\d+[\.,]?\d+\s?(â‚¬|eur|euros)?", texto, re.IGNORECASE)            if valores:                resultado.append("ðŸ’° Valores encontrados:")                resultado.extend(valores)        if any(palavra in instrucao_lower for palavra in ["data", "prazo", "vencimento"]):            datas = re.findall(r"\d{2}/\d{2}/\d{4}", texto)            if datas:                resultado.append("\nðŸ“… Datas relevantes:")                resultado.extend(datas)        if any(palavra in instrucao_lower for palavra in ["empresa", "entidade", "organizaÃ§Ã£o"]):            entidades = re.findall(r"(?i)(empresa|entidade|org\.?|instituto)\s+\w+(\s\w+)*", texto)            if entidades:                resultado.append("\nðŸ¢ Entidades detectadas:")                resultado.extend([" ".join(e).strip() for e in entidades])        if not resultado:            resultado.append("ðŸ” A instruÃ§Ã£o foi vaga. Aqui vai um resumo do conteÃºdo:")            resultado.append(texto[:1500] + ("..." if len(texto) > 1500 else ""))        return "\n".join(resultado)    def _processar_browser(self, instrucao):        try:            import pyautogui            screenshot = pyautogui.screenshot()            text = pytesseract.image_to_string(screenshot)            return self._interpretar_texto(instrucao, text)        except Exception as e:            return f"âŒ Erro ao capturar janela do navegador: {str(e)}"    def responder_local(self, pergunta):        return f"[IA Local] Resposta simulada para: '{pergunta}'"    def _fake_ia_externa(self, pergunta):        return f"[IA Externa Simulada] ({pergunta})"    def _contem_dados_sensiveis(self, pergunta):        termos = ["nif", "morada", "cc", "passaporte", "dados pessoais"]        return any(t in pergunta.lower() for t in termos)    def _tarefa_simples(self, pergunta):        palavras_chave = ["resumo", "explica", "define", "o que Ã©", "resumidamente"]        return any(p in pergunta.lower() for p in palavras_chave) and len(pergunta.split()) < 25    def _tarefa_com_criterios_especificos(self, pergunta):        especiais = ["pesquisa", "escreve um texto", "faz um artigo", "scraping", "github"]        return any(e in pergunta.lower() for e in especiais)    def _selecionar_ia_por_tarefa(self, pergunta):        if "pesquisa" in pergunta.lower():            return "gemini"        if "github" in pergunta.lower():            return "github"        if "escreve" in pergunta.lower():            return "gpt"        return "deepseek"    